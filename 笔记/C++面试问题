//32
1.C++11的类型推导：auto和decltype什么时候不能进行类型推导
auto：未初始化的变量；函数参数；模版参数；lambda表达式参数；非类型模版参数
decltype：






//34
1.#include<a.h>与#include "a.h"的区别
<>是标准库提供的头文件，""是自己自定义的头文件,告诉编译器首先在当前项目或用户指定目录中寻找，找不到再到预定义系统目录中寻找

2.讲讲STL的六大组件
容器，存放数据 分配器
算法，加工数据 仿函数
迭代器，沟通算法与容器 适配器

3.vector中size、resize、reserve、capacity的区别
size：实际存储元素数量
resize：改变容器大小，并可以指定新元素默认值
reserve: 用于预留足够内存空间提高性能，但不改变容器大小
capacity：表示容器能容纳最大的容量

4.vector中push_back和emplace_back的区别
push_back将一个已经构造好的对象拷贝一份添加到vector中；emplace_back直接在vector尾部构造对象

5.说说malloc/free和new/delete的区别
malloc/free是C语言的标准库函数，用于动态内存分配和释放；new/delete是C++的操作符，用于对象的动态内存管理
new/delete会自动调用对象的构造/析构函数，malloc/free不会调用
new因为知道类型，所以类型安全，返回的是所请求类型的指针；malloc可能会导致类型错误，尤其是类型转换不当时
数组支持：new[]和delete[]专门用于动态数组的分配和释放；malloc可分配数组，但释放用free而不是delete[]
new内存分配失败会抛出std::bad_alloc异常，malloc会返回NULL，需要程序员显式检查这个返回值
new/delete可以重载，malloc和free不能
new会考虑对象的内存对齐，malloc就不会

6.C++中堆和栈的区别
栈：系统自动分配释放；空间大小固定；计算机自动处理碎片问题；访问速度较快
堆：由程序员分配释放，new/delete动态分配；空间大小不固定；不处理；访问速度较慢

7.堆栈缓存方式的区别
栈：一级缓存，速度快；增长方式：高地址向低地址
堆：二级或更低级缓存，速度较慢；向高地址增长

8.在C++程序中调用被C语言修饰的函数，问什么要加extern"C"
C++支持函数重载，C++编译器编译时会对函数名进行"名称修饰"，C不支持重载，加extern"C"告诉C++编译器，接下来的编译不用"名称修饰"

9.什么事内存泄漏？什么是野指针？什么是内存越界？如何避免？
内存泄漏：程序申请内存后，无法释放已经申请的内存空间
如何避免：正常管理内存；使用智能指针；避免循环引用；使用内存泄漏检测工具
野指针：已经被释放的内存，但指针的值没置为nullptr
如何避免：释放内存后及时置空；避免内存的拷贝和赋值；使用智能指针
内存越界：程序访问的内存地址超出了其原本分配的内存范围
如何避免：检查数组和指针的索引；使用安全的数据结构；避免使用裸指针；进行代码审查和测试

10.描述一下封装、继承、多态
封装：隐藏对象的属性，提供公共接口，保护对象不被外界随意访问和修改
继承：新类从父类中继承属性和方法，使代码重用和扩展变得更容易
多态：
静态多态：函数重载，模版
动态多态：虚函数，基类指针或引用

11.C++构造函数是否可以抛出异常
可以，但要小心使用，因为会引发特定的行为和注意事项
行为发生：对象不会完全构造；成员对象和基类对象的销毁；
资源泄漏的发生；

12.构造函数和析构函数可以调用虚函数吗
可以，但不会表现出虚函数的多态性。因为在此时，当前对象的类型是正在构造或销毁的类，而不是派生类

13.内存对齐的原则是什么？
内存对齐原因：提高数据访问的效率（对齐的额数据通常比未对齐的数据访问更快）
内存对齐原则：自然对齐，结构体对齐（padding），对齐修饰符（alignas）

14.内联函数有什么优点？内联函数和宏定义的区别
内联函数在调用函数时，将函数代码直接插到调用点，而不是一般的函数调用
区别：
内联函数：编译时类型检查；准循C++作用域规则；支持调试
宏定义：不检查，纯文本替换；无作用域概念；不能直接调试

15.STL中set和map都是基于什么实现的
红黑树

16.什么时候要用虚析构函数
用于确保通过基类指针删除派生类对象时，能够正确调用派生类的析构函数

17.将引用作为函数返回值类型的格式、好处和需要遵守的规则
好处：避免复制大对象、提高性能、实现链式操作
格式：
Type& functionName(parameters);
const Type& functionName(parameters) const;
原则：
不要返回局部变量的引用；返回类成员的引用时要小心；返回引用的常量性

18.重载和重写的区别
重载：函数名同，参数类型、数量或顺序不用
重写：子类使用与父类中虚函数相同的函数签名，override

19.不允许重载的5个运算符
.  ::  .*  ?:  sizeof()

20.拷贝构造函数在哪几种情况下会被调用
拷贝构造：创建一个新的对象，这个新对象是用另一个同类对象进行初始化的 ClassName(const ClassName& other);
情况：对象初始化；函数参数传递（当一个对象作为非引用参数传递给函数时）；函数返回值（返回非引用或指针）；
对象数组初始化；编译器生成的临时对象

21.什么时候必须重写拷贝构造函数
类中包含动态分配的资源；
类中包含非平凡的成员对象（成员对象含有自定义逻辑的拷贝构造函数）；
需要深拷贝时；
避免默认行为的情况；
类中包含指向其他对象的指针或资源句柄

22.静态成员函数存在的意义
意义：与对象无关；访问静态成员变量；辅助函数（单例模式等）；命名空间的作用

23.流运算符为什么不能通过类的成员函数重载
对称性问题；无法直接访问流对象；扩展性

24.系统会自动打开和关闭的3个标准的文件
标准输入stdin 文件描述符为0;标准输出stdout 文件描述符为1;标准错误stderr 文件描述符为2

25.说出字符常量和字符串常量的区别，并使用sizeof计算有什么不同
字符常量：'';char;1字节
字符串常量："";const char*;包含空字符，字符数+1

26.dll和lib的区别
dll：运行时加载，链接到应用程序；共享内存
lib：编译时链接，嵌入最终的可执行文件中；不共享

27.多线程如何实现通讯，如何进行同步
线程间通信：数据传递和消息传递
方式：共享内存；消息队列
线程间同步：访问顺序和互斥
机制：互斥锁；条件变量；读写锁；信号量

28.智能指针可以放到容器中吗
可以
注意：std::unique_ptr是不可复制，但可以移动。因此，std::unique_ptr放入容器时需要使用移动语义

29.strcpy和memcry使用时的注意事项，strncpy、memncpy的区别
strcpy用于将一个字符串复制到另一个字符串中，复制包含字符串中的"\0" 
strncpy是strcpy长度受限的版本

30.const和static能同时修饰成员函数吗
不能
const成员函数，不能修改任何非mutable成员变量，也不能调用任何非const成员函数
const成员函数需要this指针来保证不修改对象的状态，而static成员函数没有this指针












