//28
1.指针占用的大小是多少
32位-4个字节 64位-8个字节

2.请解释C++中的继承和多态性

3.explicit用在哪里？有什么作用
位置：用于构造函数前面，防止类构造函数的意外调用
作用：防止类型隐式转换

4.什么是虚函数？为什么在基类中使用虚函数？

5.如何处理内存泄漏问题？提供一些常见的内存管理技术？
如何：智能指针；手动管理内存；注意资源关闭；引用计数技术；避免异常导致的泄漏；利用工具检测
技术：栈内存分配；堆内存分配

6.解释栈和堆的区别？

7.C++中动态内存分配是如何工作的？如何使用new和delete操作符号进行动态内存管理？
工作：申请内存；内存分配；使用指针；使用内存；释放内存

8.什么是析构函数？它有什么作用？
析构函数的主要作用是进行清理工作，比如释放对象在其生命周期中可能动态分配的资源，如内存、文件句柄、网络连接等。
当对象的生命周期结束时，无论是由于超出了其作用域还是被显式地删除，析构函数都会被调用，以确保资源得到妥善的释放，防止资源泄漏。

9.请解释const关键字在C++中的作用
定义常量；指针与const；函数参数与const；const成员函数；constexpr常量表达式

10.请解释引用和指针之间的区别

11.解释浅拷贝和深拷贝，并提供相应代码示例

12.解释运算符重载及其在C++中的使用场景

13.解释模版类和模版函数，并给出一个模版类或模版函数的示例底代码

14.C++中异常处理机制是如何工作的？解释try-catch块及其语法
try，catch，throw

15.列举并解释STL库中常用容器，例如vector、list、map等

16.STL迭代器是什么？请给出一个使用迭代器的示例

17.解释C++中的命名空间概念及其作用
解决：命名冲突；代码组织；模块化

18.解释静态成员变量和静态成员函数，并提供相应代码示例

19.请解释预处理器在C++中的作用，并举例说明其常见用法
作用：包含头文件；定义宏；条件编译；取消宏

20.C++如何进行文件读写操作？
ifstream，ofstream，fstream

21.解释指针与数组之间的关系，如何通过指针遍历数组？

22.列举C++常见的排序算法，并选择一个进行实现
冒泡；选择；插入；快速；归并；堆；

23.列举并解释C++中常见的设计模式，例如单例模式、观察者模式等

24.如何进行线程创建和同步操作？解释互斥锁和条件变量
thread库  ; std::mutex  ;  

25.什么是lambda表达式？有什么作用？
匿名函数；

26.C++11引入了哪些新特性？请列举几个重要的特性并简要解释他们
自动类型推导；范围for循环；lambda表达式；右值引用和移动语义；智能指针；nullptr；线程支持库；统一的初始化列表；枚举类；constexpr

27.解释auto关键字在C++11中的作用及其使用场景

28.什么是智能指针？列举几种常见的智能指针类型，并解释其特点和适用场景

29.C++异常处理机制允许抛出任意类型的异常？为什么？
允许；但一般抛出派生自C++标准异常类的对象

30.请解释动态绑定的概念及其作用
晚期绑定；虚函数；多态

//30
1.说一下虚函数是怎么实现的
虚函数表，虚函数表指针

2.父类的构造函数和析构函数能否为虚函数？这样操作导致的结果？
构造函数不能，析构函数可以

3.你了解C++11的一些特性吗
并发支持；类型推导和初始化；智能指针和内存管理；lambda表达式；新的语法和特性；类和模版的改进

4.针对指针清理，如何确定具体要清理多少空间呢
delete p会让内存分配器通过p查找相关元数据，获取分配块的大小

5.你知道怎么在main函数之前执行函数吗？
-使用全局对象的构造函数
-使用静态对象的构造函数
-使用命名空间中的对象
-使用GCC扩展__attribute__((constructor))
-使用C++11中的静态局部变量

6.你知道大小端吗？如何实现大小端转换？
大端：高字节往低地址存（符合人类）
小端：高字节往高地址存

7.原子操作是什么？
不能被中断的操作
特点：不可分割性；线程安全；低开销

8.你知道什么是死锁吗？怎么解决死锁的问题？
多线程在执行的过程中，因争夺资源造成的一种互相等待的现象
原因：互斥条件；保持和等待条件；不可剥夺条件；循环等待条件
解决：预防策略；避免策略；检查与恢复策略

9.你知道用户态和核心态的区别是什么？
本质是cpu由谁来使用的问题
用户态（目态）：应用程序
核心态（管态）：内核程序

10.从用户态调用到核心态是怎样的一个过程？
系统调用；中断；异常

11.你了解过哪些设计模式，谈谈对观察者模式的理解？

12.说说归并排序的过程？

13.说下快速排序是怎样的排序？

14.window编程相关的知识了解吗？
windows API；MFC；COM；多线程编程；GUI编程（Qt）；内存管理；

15.getmessage和peekmessage你知道有什么区别吗？
都是从消息队列中抓取消息 
前者阻塞；后者不阻塞

//32
1.C++11的类型推导：auto和decltype什么时候不能进行类型推导
auto：未初始化的变量；函数参数；模版参数；lambda表达式参数；非类型模版参数
decltype：未定义符号；不完整类型；

2.如何防止头文件被重复包含
#ifndef #define #enddif
#pragma once (有些编译器不支持)

3.volatile的作用
告诉编译器不要对该变量的访问进行优化，每次都从变量的地址进行读取

4.什么时候用array，什么时候用vector
array：固定大小，不能改变；栈上分配；编译时就知道大小，无动态内存分配释放；知道固定数量可用
vector：动态大小；堆上分配；添加删除需进行内存分配释放；不知道具体容量时可用

5.说说vector和list的优缺点
vector：
优点：支持随机访问；内存局部性；自动扩展；效率高的尾部操作
缺点：插入和删除效率低；内存重新分配
list：双向链表
优点：高效的插入和删除；稳定的迭代器
缺点：低效的随机访问；内存开销大；缓存不友好

6.虚析构函数的作用

7..so文件是什么
共享对象文件，linux中用于实现动态链接库的一种文件格式（window是dll）

8.动态库如何进行编程
编写源代码；编译成共享库；在其他程序使用动态库

9.静态链接和动态链接的区别
静态链接：编译时将库的代码直接嵌入可执行文件中
优点：独立，运行时不依赖外部库文件；启动速度快
缺点：可执行文件体积大；更新困难，需重新编译
动态链接：运行时将库加载到内存中
优点：可执行文件体积小；易于更新
缺点：依赖外部库文件；启动速度慢

10.数组与指针的区别与联系，函数指针，指针函数，指针数组，数组指针
函数指针：指向函数的指针 int (*P)(int,int) = add;
指针函数：返回指针的函数 int* getPointer(int &a){return &a;}
指针数组：每个元素都是指针的数组 int *arr[3]={&a,&b,&c};
数组指针：指向数组的指针 int arr[3]={1,2,3}; int (*ptr)[3]=&arr;

11.关于this指针你知道什么
-指向当前对象
-在成员函数中才有定义，实际第一个参数为 T* const this
-在所有非静态成员函数中隐含存在
-是一个常量指针
-可通过其返回当前对象的引用或指针，实现链式调用
-在成员函数的开始前构造，在成员函数的结束时清楚


12.描述linux下软链接和硬链接的区别
硬链接：同一个文件的不同别名；直接指向文件的数据块；不允许跨文件系统；
软链接：只存储目标路径；可跨文件系统

13.linux下如何修改文件属性以及权限
chmod chown

14.linux开发，使用多线程还是用IO复用select/epoll
多线程：
优点：并发性；独立性；利用多核
缺点：开销大；共享数据同步问题；复杂性
IO复用：
优点：高效性；扩展性；简单性
缺点：非并发性；事件驱动

15.异步，多线程和并行的区别
异步：一种编程模型，它关注的是非阻塞的执行和结果通知。异步操作可以在同一线程或不同线程上执行，具体取决于实现。
多线程：一种操作系统级别的并发机制，它允许程序同时执行多个线程。多线程本身并不保证并行执行，但它是实现并行性的常用手段之一。
并行：一种计算模式，它关注的是多个计算任务的同时执行。并行性可以通过多线程、多进程、多核处理器等多种方式实现。

16.实现一个函数统计数组中出现最多的数
哈希表

17.实现简单的智能指针

//34
1.#include<a.h>与#include "a.h"的区别
<>是标准库提供的头文件，""是自己自定义的头文件,告诉编译器首先在当前项目或用户指定目录中寻找，找不到再到预定义系统目录中寻找

2.讲讲STL的六大组件
容器，存放数据 分配器
算法，加工数据 仿函数
迭代器，沟通算法与容器 适配器

3.vector中size、resize、reserve、capacity的区别
size：实际存储元素数量
resize：改变容器大小，并可以指定新元素默认值
reserve: 用于预留足够内存空间提高性能，但不改变容器大小
capacity：表示容器能容纳最大的容量

4.vector中push_back和emplace_back的区别
push_back将一个已经构造好的对象拷贝一份添加到vector中；emplace_back直接在vector尾部构造对象

5.说说malloc/free和new/delete的区别
malloc/free是C语言的标准库函数，用于动态内存分配和释放；new/delete是C++的操作符，用于对象的动态内存管理
new/delete会自动调用对象的构造/析构函数，malloc/free不会调用
new因为知道类型，所以类型安全，返回的是所请求类型的指针；malloc可能会导致类型错误，尤其是类型转换不当时
数组支持：new[]和delete[]专门用于动态数组的分配和释放；malloc可分配数组，但释放用free而不是delete[]
new内存分配失败会抛出std::bad_alloc异常，malloc会返回NULL，需要程序员显式检查这个返回值
new/delete可以重载，malloc和free不能
new会考虑对象的内存对齐，malloc就不会

6.C++中堆和栈的区别
栈：系统自动分配释放；空间大小固定；计算机自动处理碎片问题；访问速度较快
堆：由程序员分配释放，new/delete动态分配；空间大小不固定；不处理；访问速度较慢

7.堆栈缓存方式的区别
栈：一级缓存，速度快；增长方式：高地址向低地址
堆：二级或更低级缓存，速度较慢；向高地址增长

8.在C++程序中调用被C语言修饰的函数，问什么要加extern"C"
C++支持函数重载，C++编译器编译时会对函数名进行"名称修饰"，C不支持重载，加extern"C"告诉C++编译器，接下来的编译不用"名称修饰"

9.什么事内存泄漏？什么是野指针？什么是内存越界？如何避免？
内存泄漏：程序申请内存后，无法释放已经申请的内存空间
如何避免：正常管理内存；使用智能指针；避免循环引用；使用内存泄漏检测工具
野指针：已经被释放的内存，但指针的值没置为nullptr
如何避免：释放内存后及时置空；避免内存的拷贝和赋值；使用智能指针
内存越界：程序访问的内存地址超出了其原本分配的内存范围
如何避免：检查数组和指针的索引；使用安全的数据结构；避免使用裸指针；进行代码审查和测试

10.描述一下封装、继承、多态
封装：隐藏对象的属性，提供公共接口，保护对象不被外界随意访问和修改
继承：新类从父类中继承属性和方法，使代码重用和扩展变得更容易
多态：
静态多态：函数重载，模版
动态多态：虚函数，基类指针或引用

11.C++构造函数是否可以抛出异常
可以，但要小心使用，因为会引发特定的行为和注意事项
行为发生：对象不会完全构造；成员对象和基类对象的销毁；
资源泄漏的发生；

12.构造函数和析构函数可以调用虚函数吗
可以，但不会表现出虚函数的多态性。因为在此时，当前对象的类型是正在构造或销毁的类，而不是派生类

13.内存对齐的原则是什么？
内存对齐原因：提高数据访问的效率（对齐的额数据通常比未对齐的数据访问更快）
内存对齐原则：自然对齐，结构体对齐（padding），对齐修饰符（alignas）

14.内联函数有什么优点？内联函数和宏定义的区别
内联函数在调用函数时，将函数代码直接插到调用点，而不是一般的函数调用
区别：
内联函数：编译时类型检查；准循C++作用域规则；支持调试
宏定义：不检查，纯文本替换；无作用域概念；不能直接调试

15.STL中set和map都是基于什么实现的
红黑树

16.什么时候要用虚析构函数
用于确保通过基类指针删除派生类对象时，能够正确调用派生类的析构函数

17.将引用作为函数返回值类型的格式、好处和需要遵守的规则
好处：避免复制大对象、提高性能、实现链式操作
格式：
Type& functionName(parameters);
const Type& functionName(parameters) const;
原则：
不要返回局部变量的引用；返回类成员的引用时要小心；返回引用的常量性

18.重载和重写的区别
重载：函数名同，参数类型、数量或顺序不用
重写：子类使用与父类中虚函数相同的函数签名，override

19.不允许重载的5个运算符
.  ::  .*  ?:  sizeof()

20.拷贝构造函数在哪几种情况下会被调用
拷贝构造：创建一个新的对象，这个新对象是用另一个同类对象进行初始化的 ClassName(const ClassName& other);
情况：对象初始化；函数参数传递（当一个对象作为非引用参数传递给函数时）；函数返回值（返回非引用或指针）；
对象数组初始化；编译器生成的临时对象

21.什么时候必须重写拷贝构造函数
类中包含动态分配的资源；
类中包含非平凡的成员对象（成员对象含有自定义逻辑的拷贝构造函数）；
需要深拷贝时；
避免默认行为的情况；
类中包含指向其他对象的指针或资源句柄

22.静态成员函数存在的意义
意义：与对象无关；访问静态成员变量；辅助函数（单例模式等）；命名空间的作用

23.流运算符为什么不能通过类的成员函数重载
对称性问题；无法直接访问流对象；扩展性

24.系统会自动打开和关闭的3个标准的文件
标准输入stdin 文件描述符为0;标准输出stdout 文件描述符为1;标准错误stderr 文件描述符为2

25.说出字符常量和字符串常量的区别，并使用sizeof计算有什么不同
字符常量：'';char;1字节
字符串常量："";const char*;包含空字符，字符数+1

26.dll和lib的区别
dll：运行时加载，链接到应用程序；共享内存
lib：编译时链接，嵌入最终的可执行文件中；不共享

27.多线程如何实现通讯，如何进行同步
线程间通信：数据传递和消息传递
方式：共享内存；消息队列
线程间同步：访问顺序和互斥
机制：互斥锁；条件变量；读写锁；信号量

28.智能指针可以放到容器中吗
可以
注意：std::unique_ptr是不可复制，但可以移动。因此，std::unique_ptr放入容器时需要使用移动语义

29.strcpy和memcry使用时的注意事项，strncpy、memncpy的区别
strcpy用于将一个字符串复制到另一个字符串中，复制包含字符串中的"\0" 
strncpy是strcpy长度受限的版本

30.const和static能同时修饰成员函数吗
不能
const成员函数，不能修改任何非mutable成员变量，也不能调用任何非const成员函数
const成员函数需要this指针来保证不修改对象的状态，而static成员函数没有this指针












