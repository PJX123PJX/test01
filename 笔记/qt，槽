

//QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));
其中， sender 是发射信号的对象的名称； signal()是信号，信号可以看作特殊的函数，需要带有括
号，有参数时还需要指明各参数类型； receiver 是接收信号的对象的名称； slot()是槽函数，需要带
有括号，有参数时还需要指明各参数类型。
SIGNAL 和 SLOT 是 Qt 的宏，分别用于指明信号和槽函数，并将它们的参数转换为相应的字
符串。关于信号与槽的使用，有以下一些规则需要注意。
（ 1）一个信号可以连接多个槽函数，例如：
connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(addFun(int)));
connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(updateStatus(int)));
当一个信号与多个槽函数关联时，槽函数按照建立连接时的顺序依次运行。
当信号和槽函数带有参数时，在函数 connect()里要指明各参数的类型，但不用指明参数名称。
 （2）多个信号可以连接同一个槽函数。例如在本示例中， 3 个选择颜色的单选按钮的 clicked()
信号关联到相同的自定义槽函数 do_setFontColor()。
connect(ui->radioBlack,SIGNAL(clicked()), this, SLOT(do_setFontColor()));
connect(ui->radioRed, SIGNAL(clicked()), this, SLOT(do_setFontColor()));
connect(ui->radioBlue, SIGNAL(clicked()), this, SLOT(do_setFontColor()));
（ 3）一个信号可以连接另一个信号，例如：
connect(spinNum, SIGNAL(valueChanged(int)), this, SIGNAL(refreshInfo(int)));
这样，当发射一个信号时，也会发射另一个信号，以实现某些特殊的功能。
（ 4）严格的情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参
数。如果参数不匹配，会出现编译错误或运行错误。
（ 5）在使用信号与槽的类中，必须在类的定义中插入宏 Q_OBJECT。
（ 6）当一个信号被发射时，与其关联的槽函数通常被立即运行，就像正常调用函数一样。只
有当信号关联的所有槽函数运行完毕后， 才运行发射信号处后面的代码。
函数 connect()有多种参数形式，有一种常用的形式是不使用 SIGNAL 和 SLOT 宏，而是使用
函数指针。例如，在示例项目 samp2_1 的文件 ui_widget.h 中，函数 setupUi()中有如下的语句：
QObject::connect(btnClose, &QPushButton::clicked, Widget, qOverload<>(&QWidget::close));
//connect(lineEdit, &QLineEdit::textChanged, this, &Widget::do_textChanged);
对于具有默认参数的信号，即信号名称是唯一的，不存在参数不同的其他同名的信号，可以
使用这种函数指针形式进行关联
QLineEdit 有一个信号 textChanged(QString)，不存在参数不同的其他 textChanged()信号，自定
义窗口类 Widget 里有一个槽函数 do_textChanged(QString)。这样就可以用上面的语句将此信号与
槽关联起来，无须出现函数参数。当信号的参数比较多时，这种写法简单一些。
如果在窗口类 Widget 里设计了如下的两个自定义槽函数：
void do_click(bool checked);
void do_click( );
那么使用如下的代码进行信号与槽的连接时，编译会出现错误。
connect(ui->checkBox, &QCheckBox::clicked, this, &Widget::do_click);
这是因为 QCheckBox 的 clicked()信号是 overload 型信号， do_click()是 overload 型槽函数，信
号与槽函数无法匹配。这时需要使用模板函数 qOverload()来明确参数类型，如果写成下面的语句
在编译时就没有问题。
connect(ui->checkBox, &QCheckBox::clicked, this, qOverload<bool>(&Widget::do_click));
connect(ui->checkBox, &QCheckBox::clicked, this, qOverload<>(&Widget::do_click));
第一行语句是将信号 clicked(bool)与槽函数 do_click(bool)连接， 第二行语句是将信号 clicked()
与槽函数 do_click()连接。模板函数 qOverload()的作用是明确 overload 型函数的参数类型。
因此，对于 overload 型信号， 只要槽函数不是 overload 型， 就可以使用传递函数指针的 connect()
来进行信号与槽的关联， Qt 会根据槽函数的参数自动确定使用哪个信号。我们在设计槽函数的时
候一般也不会设计成 overload 型的。
• Qt::AutoConnection（默认值） ：如果信号的接收者与发射者在同一个线程中，就使用
Qt::DirectConnection 方式，否则使用 Qt::QueuedConnection 方式，在信号发射时自动确定
关联方式。
• Qt::DirectConnection：信号被发射时槽函数立即运行，槽函数与信号在同一个线程中。
• Qt::QueuedConnection：在事件循环回到接收者线程后运行槽函数，槽函数与信号在不同
的线程中。
• Qt::BlockingQueuedConnection：与 Qt::QueuedConnection 相似，区别是信号线程会阻塞，
直到槽函数运行完毕。当信号与槽函数在同一个线程中时绝对不能使用这种方式，否则会
造成死锁。
//this->connect(spinNum, SIGNAL(valueChanged(int)), SLOT(updateStatus(int)));
同connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(updateStatus(int)));
this 表示窗口对象， updateStatus()是窗口类里定义的一个槽函数。

信号函数必须是无返回值的函数，但是可以有输入参数。信号函数无须实现，而只需在某些
条件下被发射。例如，函数 incAge()中会发射信号 ageChanged()，其代码如下：
signals:  void ageChanged( int value);
void QPerson::incAge()
{
	m_age++;
    emit ageChanged(m_age); //发射信号
}

//void 类名::on_控件名_信号() ｛...｝
直接命名槽函数名，在Qt中，按以上规则给槽函数命名可直接将控件的信号关联到槽函数：








